# 第一天：高性能线程池启动

## 1. 目标 (第 1 个月)
根据你的《AI 时代 C++ 架构师进阶指南》，我们的第一个重要里程碑是构建一个**高性能线程池**。
这不仅仅是一个玩具项目；它是理解并发编程的基础，而并发是架构师的关键技能。

**目标特性：**
- **任务窃取 (Task Stealing)**（高级特性，用于负载均衡）
- **优先级队列 (Priority Queues)**（关键任务优先运行）
- **现代 C++**（C++17/20 特性）

## 2. 推荐的开源参考
开始之前，你需要建立一个基本线程池的心智模型。

*   **项目**: `progschj/ThreadPool` (在 GitHub 上搜索)
*   **推荐理由**: 它是简单、仅头文件的 C++11 线程池的“黄金标准”。代码只有约 100 行。
*   **关注点**:
    1.  `std::vector<std::thread>` 如何存储工作线程。
    2.  `std::condition_variable` 如何唤醒休眠的线程。
    3.  `enqueue` 的语法（它使用了变参模板和 `std::future`，起初可能比较棘手）。

## 3. 你的编码流程 (过程)
不要试图今天就写出“最终版本”。我们将采用**迭代式方法**。

### 第一阶段：骨架 (今天的目标)
**目标**: 一个只能执行 `void` 函数的简易线程池。
1.  **环境**: 设置 `CMakeLists.txt` 和基本的项目结构。
2.  **循环**: 创建 `N` 个线程，它们在一个 `while(true)` 循环中运行。
3.  **队列**: 使用 `std::queue<std::function<void()>>` 存储任务。
4.  **锁**: 使用 `std::mutex` 和 `std::unique_lock` 保护队列。
5.  **信号**: 当任务到来时，使用 `std::condition_variable` 唤醒线程。

### 第二阶段：功能与健壮性 (第 2-3 天)
1.  **优雅退出**: 确保线程池销毁时所有线程都能干净地停止 (RAII)。
2.  **返回值**: 升级队列以处理 `std::future`，以便我们可以获取任务结果。

### 第三阶段：高性能 (第 4-10 天)
1.  **锁竞争**: 测量性能。单一互斥锁将成为瓶颈。
2.  **任务窃取**: 给每个线程分配自己的队列 (Deque) 以减少锁竞争。
3.  **优化**: 尽可能使用 `std::atomic`。
